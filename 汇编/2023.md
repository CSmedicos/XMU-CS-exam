# 2023期末试卷答案

[toc]

<<<<<<< Updated upstream:汇编/2023.md
=======
## 2008A

### 2008A-1读程序题

以下程序中有4处标记，请给出每处标记指令第一次执行前堆栈段的使用情况，并请说明该程序的主要功能和运行结果。

```asm
data    segment
num1    dw      0
num2    dw      0ffffh
num3    dw      5555h
data    ends
code1   segment
        assume  cs:code1,ds:data
max     macro   K , A , B , C
        local   next , out
        mov     bx , A
        IF      K-1
        IF      K-2
        cmp     c , bx
        JLE     next
        mov     bx , c
        endif
next:
        cmp     B , bx
        jle     out
        mov     bx , B
        endif
out:
        endm
main    proc    far
start:
        push    ds
        sub     ax , ax
        push    ax
        mov     ax , data
        mov     ds , ax

count = 0
        rept    3
count = count+1
        max     count , num1 , num2 , num3
        call    far ptr output                            ①
        endm
        ret
main    endp
code1   ends
code2   segment
        assume  cs:code2 , ds:data
output  proc    far
        mov     ch , 4                                ②
rotate:
        mov     cl , 4
        rol     bx , cl
        mov     al , bl
        and     al , 0fh
        add     al , 30h
        cmp     al , 3ah
        jl      printit
        add     al , 7h
printit:
        mov     dl , al
        mov     ah , 2
        int     21h
        dec     ch
        jnz     rotate
        call    crlf
        ret                                            ③
output  endp
crlf    proc    near
        mov     dl , 0dh                                ④
        mov     ah , 2
        int     21h
        mov     dl , 0ah
        mov     ah , 2
        int     21h
        ret
crlf    endp
code2   ends
        end     start
```

⑤请说明程序功能
⑥程序运行结果

1）
堆栈段使用情况

<1>
|     |
| --- |
|     |
| 0   |
| ds  |
|     |

sp=0fffch

<2>
|     |
| --- |
|     |
| IP  |
| CS  |
| 0   |
| ds  |
|     |

sp=0fff9h

<3>
|     |
| --- |
|     |
| IP  |
| CS  |
| 0   |
| ds  |
|     |


<4>
|     |
| --- |
|     |
| IP  |
| IP  |
| CS  |
| 0   |
| ds  |
|     |

2）
程序功能

输出三个数最大的

3）运行结果

5555

### 2008A-2填空题

以下程序实现接收单个字符输入，统计数据段中已有4个字符串中包含有输入字符的串的个数并显示出来。程序中有10处空白，请填上相应的指令，使程序完整。每空限填一条指令。并请写出程序运行的结果。

题目代码：

```asm
data    segment
str1    db 'Happy   '
str2    db 'Love    '
str3    db 'Marriage'
str4    db 'Hate    '
data    ends
code    segment
        assume cs:code , ds:data
main    proc    far
start:
        push    ds
        sub     ax , ax
        push    ax
        mov     ax , data
        mov     ds , ax
                ①       

                ②       
        int     21h
        mov     bx , 0
        mov     dl , 0
search:
                ③       
        push    bx
        shl     bx , cl
                ④       
                ⑤       
        cld
        ⑥       
        jne     next
        inc     dl
next:
                ⑦       
        inc     bx
        cmp     bx , 4
        jnz     search

                ⑧       
        ⑨       
        int     21h
        ret
main    endp
code    ends
        ⑩      
```

```asm
mov es,ax
mov ah,01h
mov cl,3
lea di,str1[bx]
mov cx,8
repne scasb
pop bx
mov ah,02h
add dl,30h
end start
```

```asm
data segment
    str1 db 'happy   '
    str2 db 'Love    '
    str3 db 'Marriage'
    str4 db 'hate    '
data ends
code segment
assume cs:code,ds:data,es:data
main proc far
start:
    push ds
    sub ax,ax
    push ax
    mov ax,data
    mov ds,ax
    mov es,ax
    mov ah,01h
    int 21h
    mov bx,0
    mov dl,0
search:
    mov cl,3
    push bx
    shl bx,cl
    lea di,str1[bx]
    mov cx,8
    cld
    repne scasb
    jne next
    inc dl
next:
    pop bx
    inc bx
    cmp bx,4
    jnz search
    mov ah,02h
    add dl,30h
    int 21h
    ret
main endp
code ends
end main
```

答案：

```asm
mov es,ax      ;1
mov ah,1       ;2
mov cl,3       ;3,和shl bx,cl配合,相当于bx*=8,得到字符在数据段开始的位置
mov cx,8       ;4
lea di,str1[bx];5
repne scasb    ;6,查找al对应的字符是否在di里
pop bx         ;7
add al,30h     ;8
mov ah,2       ;9
end start      ;10
```

### 2008A-3编程计算题

数据段中定义了4个<mark>带符号字</mark>数据：A、B、C、D，编写指令计算出A+（B*10+C）/D的结果，并说明结果的存放情况。

```asm
datarea segment
        a       dw 100
        b       dw 200
        cc      dw 300        ;在真实的汇编编程中，c是一个关键字，会报错。但是考试还得写成“C”
        d       dw 23
datarea ends
prognam segment
main proc far
                assume cs:prognam,ds:datarea
        start:  
                push   ds
                sub    ax,ax
                push   ax
                mov    ax,datarea
                mov    ds,ax
            
        ;A+(B*10+C)/D
        ;考试从这儿开始写
                mov    ax,b
                mov    bx,10
                imul   bx
                mov    cx,dx
                mov    bx,ax
                mov    ax,cc
                cwd
                add    ax,bx
                adc    dx,cx
                idiv   d
                add    ax,a
        ;考试从这儿结束
                ret
main endp
prognam ends
    end start
```

结果存在ax中

### 2008A-4编程循环题

已知数组A包含15个互不相等的整数，数组B包含20个互不相等的整数。试编制一程序，统计既在A中出现又在B中出现的元素的个数，并以10进制显示出来。

```asm
;稳妥版
datarea segment
    a       db 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45
    b       db 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40
    a_count db 15
    b_count db 20
    ;res:[6, 12, 18, 24, 30, 36]
datarea ends
prognam segment
main proc far
              assume cs:prognam,ds:datarea
    start:    
              push   ds
              sub    ax,ax
              push   ax
              mov    ax,datarea
              mov    ds,ax
            
              mov    ax,0                     ;count of same numbers
              mov    si,0                     ;a[si]
    loop1:    
              mov    di,0
    loop2:    
              mov    bl,a[si]
              cmp    bl,b[di]
              jne    not_equal
              inc    ax
    not_equal:
              inc    di
              cmp    di,20
              jl     loop2
              inc    si
              cmp    si,15
              jl     loop1
              call   bin2dec
              ret
main endp
bin2dec proc
    ;ax/src=al...ah
              mov    cx,0
    loop3:    
              mov    bl,10
              div    bl
              push   ax
              xor    ah,ah
              inc    cx
              cmp    al,0
              jg     loop3
    putchar:  
              pop    dx
              mov    dl,dh
              add    dl,30h
              mov    ah,2
              int    21h
              loop   putchar
              ret
bin2dec endp
prognam ends
end start
```

### 2008A-5编程中断题

编写程序通过接管1CH中断的方式实现每隔1秒钟读取一次打印机状态寄存器（端口号397H）内容，如果最高位为0，显示“busy”（20分）

```
data segment
    count dw 1
    mes db 'busy',13,10,'$'
data ends
code segment
main proc far
assume cs:code, ds:data
start:
    push ds
    sub ax,ax
    push ax
    mov ax,data
    mov ds,ax
    mov es,ax

;保存旧的中断向量
    mov al,1c
    mov ah,35h
    int 21h
    push es
    push bx

    push ds 

    mov dx,offset check
    mov ax,seg check
    mov ds,ax
    mov al,1ch
    mov ah,25h
    int 21h

    pop ds
    ;打开定时器
    in al,21h
    and al,11111110b
    out 21h,al
    sti

    mov di,20000
delay:
    mov si,30000
delay1:
    dec si
    jnz delay1
    dec di 
    jnz delay
    ;重新设置回旧的中断向量
    cli
    pop dx
    pop ds
    mov al,1ch
    mov ah,25h
    int 21h

    ret
main endp
check proc near
    push ax
    push dx
    push ds

    mov ax,data
    mov ds,ax
    sti
    dec count 
    jnz exit

    mov dx,397h
    in al,dx
    test al,10000000b
    jnz exit2
    call output
exit2:
    mov count,18
exit:
    cli
    pop ds
    pop dx
    pop ax
    iret
check endp
output proc near
    lea dx,mes
    mov ah,09h
    int 21h
    ret
output endp
code ends
end start
```
## 2011

### 2、（填空题）

1、无答案版

仓库管理中，存有有关库存品的编号、名称情况的表格，根据用户提供的编号可以找到有关材料名。假设表格中共有六种库存品，以下程序可根据用户提供的两位编号在终端上显示其名称。
```
datasg segment para 'data'
mess1 db 'stock number?', 13, 10, '$';
;
stoknin label byte
 1)
 2)
 3)
;
stoktab db '05', 'Excavtors '
db '08', 'Lifters '
db '09', 'Presses '
db '12', 'Vavles '
db '23', 'Processors '
db '27', 'Pumps '
;
descrn db 14 dup(20h), 13, 10, '$'
mess db 'Not in table!', '$'
datasg ends
;***********************************************
codesg segment para 'code'
assume cs: codesg, ds: datasg, es: datasg
;-----------------------------------------------
main proc far
push ds
sub ax, ax
push ax
mov ax, datasg
mov ds, ax
4)
start:
lea dx, mess1
mov ah, 09
int 21h
lea dx, stoknin
mov ah, 0ah
int 21h
cmp act, 0
 5)
mov al, stokn
mov ah, stokn+1
mov cx, 06
lea si, stoktab
a20:
cmp ax, word ptr [si]
 6)
add si, 14
 7)
lea dx, mess
mov ah, 09
int 21h
jmp exit
a30:
 8)
 9)
 10)
;
lea dx, descrn
mov ah, 09
int 21h
jmp start
exit:
ret
main endp
;----------------------------------------------
codesg ends
;**********************************************
end main
```
2、答案版

```
datasg segment para 'data'
mess1 db 'stock number?', 13, 10, '$';
;
stoknin label byte
 1)max db 3
 2)act db ?
 3)stokn db 3 dup(?);这里标准答案是5 dup(?)，我不理解
;
stoktab db '05', 'Excavtors '
db '08', 'Lifters '
db '09', 'Presses '
db '12', 'Vavles '
db '23', 'Processors '
db '27', 'Pumps '
;
descrn db 14 dup(20h), 13, 10, '$'
mess db 'Not in table!', '$'
datasg ends
;***********************************************
codesg segment para 'code'
assume cs: codesg, ds: datasg, es: datasg
;-----------------------------------------------
main proc far
push ds
sub ax, ax
push ax
mov ax, datasg
mov ds, ax
4)mov es,ax
start:
lea dx, mess1
mov ah, 09
int 21h
lea dx, stoknin
mov ah, 0ah
int 21h
cmp act, 0
5)jle exit
mov al, stokn
mov ah, stokn+1
mov cx, 06
lea si, stoktab
a20:
cmp ax, word ptr [si]
6)jz a30
add si, 14
7)loop a20
lea dx, mess
mov ah, 09
int 21h
jmp exit
a30:
 8)lea di,descrn
 9)mov cx,14
 10)rep movsb
;
lea dx, descrn
mov ah, 09
int 21h
jmp start
exit:
ret
main endp
;----------------------------------------------
codesg ends
;**********************************************
end main
```
### 3、
已知 A, B, C, D 为 16 位带符号数，请编写程序段计算 [120 - (A + B * C)] / D，并将商和余数依次保存到以 E 开头的连续两个字空间中。（20分）

```
data segment
E dw 2 dup(?)
data ends
code segment
此处省略前面的初始化
mov ax,b
imul c
mov cx,ax
mov bx,dx
mov ax,a
cwd
add cx,ax
adc bx,dx
mov ax,120
cwd
sub ax,cx
sbb dx,bx
idiv d
mov E,ax
mov E+2,dx
code ends
```

## 2023

>>>>>>> Stashed changes:汇编/期末试卷答案.md
1，2题代码如下：

```asm
DATA SEGMENT
    MSG     DB 'WHICH CITY?',13,10,'$'
    CITYIN  DB 10,?,10 DUP (?)
    CITYOUT DB 13,'UMT+0',?,32 DUP (?),13,10,'$'
    CITYTAB DB 'LONDON, UNITED KINGDOM          '
            DB 'BERLIN, GERMANY                 '
            DB 'ATHENS, GREECE                  '
            DB 'MOSCOW, RUSSIA                  '
            DB 'DUBAI, UNITED ARAB EMIRATES     '
            DB 'ISLAMABAD, PAKISTAN             '
            DB 'ALMATY, KAZAKHSTAN              '
            DB 'BANGKOK, THAILAND               '
            DB 'BEIJING, CHINA                  '
            DB 'I DO NOT KNOW :(                '
DATA ENDS

CODE SEGMENT
MAIN PROC FAR
           ASSUME CS:CODE, DS:DATA, ES:DATA
    START: PUSH   DS                           ;❀
           SUB    AX,AX
           PUSH   AX
           MOV    AX,DATA
           MOV    DS,AX
          ;填空①，扩展段
           CALL   GETT                         ;甲
           PUSH   AX
           CALL   GETL
           ;填空②
           CALL   NOW
           RET
MAIN ENDP

    ;ah=时，al=分
GETT PROC
           MOV    AL, 4                        ;看附录，时
           OUT    70H,AL
           IN     AL, 71H
           MOV    AH, AL
           MOV    AL, 2                        ;分？原来的附录错了
           OUT    70H, AL
           IN     AL, 71H
           RET
GETT ENDP

GETL PROC
           LEA    DX, MSG                
           MOV    AH,09H
           INT    21H

           ;填空③
           MOV    AH,0AH
           INT    21H
    
           MOV    BX,0
           LEA    DI,CITYTAB

    SRCH:  
           ;填空④
           ;填空⑤
           SUB    CH,CH
           CLD
           PUSH   DI
           REPE   CMPSB                 
          ;填空⑥
           JE     FOUND
           INC    BX
           MOV    CL,5
           PUSH   BX
           ;填空⑦
           LEA    DI,CITYTAB[BX]
           POP    BX
           ;填空⑧ 
           JL     SRCH

    FOUND: 
           MOV    CITYOUT+6,BL
           ;填空⑨
           MOV    SI,DI
           LEA    DI,CITYOUT+7
           ;填空⑩
           CLD
           REP    MOVSW
           LEA    DX,CITYOUT
           MOV    AH,09
           INT    21H
           RET   
GETL ENDP                                      ;乙

NOW PROC NEAR
           PUSH   BP
           MOV    BP,SP                        ;丙
           PUSH   CX
           PUSH   AX
           PUSH   DX
           MOV    BX,[BP+4]
           CMP    BX,09
           JZ     RTN
           MOV    DX,[BP+6]                    ;△
           MOV    AL,DH
           ADD    AL,24H
           DAA
           ADD    AL,BL
           DAA
           SUB    AL,8
           DAS                   
           CMP    AH,24H
           JL     OUTPUT
           SUB    AL, 24
           DAS

    OUTPUT:
           MOV    BH, AL
           MOV    BL, DL
           MOV    CH, 4
    ROTATE:
           MOV    CL, 4
           ROL    BX, CL
           MOV    AL, BL
           AND    AL, 0FH
           ADD    AL, 30H
           MOV    DL, AL
           MOV    AH, 2
           INT    21H
           DEC    CH
           PUSHF                               ;☆
           CMP    CH, 02
           JNZ    NO
           MOV    DL, 3AH
           MOV    AH, 02H
           INT    21H
    NO:    
           POPF                                ;☆
           JNZ    ROTATE
    RTN:   
           POP    DX
           POP    AX
           POP    CX
           POP    BP
           RET    4                            ;丁
NOW ENDP
CODE ENDS
END START
```

## 2023-1程序填空题

以上程序中子程序GETL实现接受一个城市名输入，然后在数据段定义的城市名字符串列表中进行搜索，如找到则输出相应完整字符串，并获得序列号。该子程序及相关部分程序中有十处空白，已用①到⑩标出。请将空白处填入适当的指令，每空2分，每空限填一条指令。

（确定答案，已经调试能够正常运行）

```asm
DATA SEGMENT
    MSG     DB 'WHICH CITY?',13,10,'$'
    CITYIN  DB 10,?,10 DUP (?)
    CITYOUT DB 13,'UMT+0',?,32 DUP (?),13,10,'$'
    CITYTAB DB 'LONDON, UNITED KINGDOM          '
            DB 'BERLIN, GERMANY                 '
            DB 'ATHENS, GREECE                  '
            DB 'MOSCOW, RUSSIA                  '
            DB 'DUBAI, UNITED ARAB EMIRATES     '
            DB 'ISLAMABAD, PAKISTAN             '
            DB 'ALMATY, KAZAKHSTAN              '
            DB 'BANGKOK, THAILAND               '
            DB 'BEIJING, CHINA                  '
            DB 'I DO NOT KNOW :(                '
DATA ENDS

CODE SEGMENT
MAIN PROC FAR
           ASSUME CS:CODE, DS:DATA, ES:DATA
    START: PUSH   DS                           ;❀
           SUB    AX,AX
           PUSH   AX
           MOV    AX,DATA
           MOV    DS,AX
           mov    es,ax                        ;填空①，扩展段
           CALL   GETT                         ;甲
           PUSH   AX
           CALL   GETL
           push BX                          ;填空②
           CALL   NOW
           RET
MAIN ENDP

    ;ah=时，al=分
GETT PROC
           MOV    AL, 4                        ;看附录，时
           OUT    70H,AL
           IN     AL, 71H
           MOV    AH, AL
           MOV    AL, 2                        ;分？原来的附录错了
           OUT    70H, AL
           IN     AL, 71H
           RET
GETT ENDP

GETL PROC
           LEA    DX, MSG                      ;输出'WHICH CITY?'
           MOV    AH,09H
           INT    21H

           lea    dx,CITYIN                    ;填空③,输入字符串
           MOV    AH,0AH
           INT    21H
    
           MOV    BX,0
           LEA    DI,CITYTAB

    SRCH:  
    ;这里开始比较了
           mov    cl,CITYIN[1]                 ;填空④，字符串长度
           lea    si,cityin[2]                 ;填空⑤
           SUB    CH,CH
           CLD
           PUSH   DI
           REPE   CMPSB                        ;比较是否相等
           pop    di                           ;填空⑥
           JE     FOUND
           INC    BX
           MOV    CL,5
           PUSH   BX
           shl    bx,cl                        ;填空⑦,bx*=32,字符串长度
           LEA    DI,CITYTAB[BX]
           POP    BX
           cmp    bx,9                         ;填空⑧ 
           JL     SRCH

    FOUND: 
           MOV    CITYOUT+6,BL
           add    CITYOUT+6,30h                ;填空⑨(前面pop过了，我感觉这里是add  CITYOUT+6,30h)
           MOV    SI,DI
           LEA    DI,CITYOUT+7
           mov    cx, 16                       ;填空⑩
           CLD
           REP    MOVSW
           LEA    DX,CITYOUT
           MOV    AH,09
           INT    21H
           RET   
GETL ENDP                                      ;乙

NOW PROC NEAR
           PUSH   BP
           MOV    BP,SP                        ;丙
           PUSH   CX
           PUSH   AX
           PUSH   DX
           MOV    BX,[BP+4]
           CMP    BX,09
           JZ     RTN
           MOV    DX,[BP+6]                    ;△
           MOV    AL,DH
           ADD    AL,24H
           DAA
           ADD    AL,BL
           DAA
           SUB    AL,8
           DAS                 
           CMP    AH,24H
           JL     OUTPUT
           SUB    AL, 24
           DAS

    OUTPUT:
           MOV    BH, AL
           MOV    BL, DL
           MOV    CH, 4
    ROTATE:
           MOV    CL, 4
           ROL    BX, CL
           MOV    AL, BL
           AND    AL, 0FH
           ADD    AL, 30H
           MOV    DL, AL
           MOV    AH, 2
           INT    21H
           DEC    CH
           PUSHF                               ;☆
           CMP    CH, 02
           JNZ    NO
           MOV    DL, 3AH
           MOV    AH, 02H
           INT    21H
    NO:    
           POPF                                ;☆
           JNZ    ROTATE
    RTN:   
           POP    DX
           POP    AX
           POP    CX
           POP    BP
           RET    4                            ;丁
NOW ENDP
CODE ENDS
END START
```

## 2023-2读程序题

1.❀处的标号START作用是什么？（2分）
START是程序的入口标号，标志程序从这里开始执行，并作为程序入口点被汇编器用在 END START 指令中，指定程序从此处开始运行。

2.GETT子程序的主要功能是什么？（请参看附录2）（2分）
GETT 子程序的功能是从 CMOS 实时时钟读取当前的时间（小时和分钟）。其中，高字节 AH 保存当前小时，低字节 AL 保存当前分钟。

3.请描述出IP指向甲、乙、丙、丁等四处时，堆栈段的使用情况，包括堆栈指针和相应存储单元的内容。（6分）

#### 甲
| 堆栈   |
| ---- |
|      |
|      |
| 0    |
| (ds) |

sp=0FFFCh

#### 乙
| 堆栈   |
| ---- |
|      |
|  (IP)    |
| 0    |
| (ds) |

#### 丙
| 堆栈   |
| ---- |
|  (BP)    |
|  (IP)    |
| 0    |
| (ds) |

#### 丁
| 堆栈   |
| ---- |
|      |
|      |
| 0    |
| (ds) |

4.△处的语句作用是什么？为什么此处要使用BP寄存器？（2分）
注意，上方答案已经更新。在CALL GETT之后，PUSH AX； 在调用CALL GETL之后，要PUSH BX而不是POP AX。因此现在栈里面，有两个数据，PUSH AX是把时钟数据放入栈中，PUSH BX是把时区信息放到栈中。在△处，[BP+6]获取的是时钟信息。上面的[BP+4]获取的是时区信息。 

使用 BP 的原因：
由于子程序执行时，SP 的值会随着入栈、出栈操作不断变化，而 BP 被固定用于指向当前栈帧，便于访问传入的参数和局部变量。

5.☆处的两个语句作用是什么？如果去掉会有什么影响？（2分）
作用：
PUSHF和POPF用于保存和恢复标志寄存器FLAGS的状态。
这两个指令确保在循环左移ROL和条件判断JNZ时，标志寄存器的原始状态不受破坏。
去掉的影响：
如果没有PUSHF和POPF，标志寄存器的状态可能在子程序中被错误修改，导致循环条件或程序逻辑出错。

6.NOW子程序的主要功能是什么？（2分）  
根据输入的时间信息和城市时区差异，计算并显示当前的城市时间（以 "HH:MM" 格式输出）。

关于NOW的逻辑的解释：为什么△附近的代码，要先加24,还要减24,还有一个减8？ **答：** 这里，获取到的小时是使用BCD码的，```MOV AL,DH```的指令，把BCD编码的小时存入AL。注意在MS DOS和Microsoft Windows中，主板的CMOS存储的时间是本地时间。**此题目默认电脑在中国，CMOS中存储的是北京时间。**北京时间是UTC+8,所以要先减8。CITYAB中，每一行的时区依次加1。也就是LONDON是UTC+0, BERLIN是UTC+1 ... BEIJING是UTC+8。所以要先减8再加上时区。先加24再减24的目的是，防止减8之后变成负数。

7.丁处指令的功能是什么？（2分）

（书P207,ret的本质是pop sp,此处ret 4是在pop ip的基础上再pop sp+2,pop sp+4)

```RET 4```指令用于从子程序返回，同时清理调用时传入的 4 字节参数。（这四个字节的参数是，```CALL GETT```之后的```PUSH AX```，和```CALL GETL```后的```PUSH BX```）调用者堆栈的指针自动调整，避免手动释放参数。

8.此程序的完整功能是什么?请简要描述,并用合适的自拟输入内容演示程序行后可能输出的典型结果(GETT子程序功能请参看附录)(2分)

程序功能：
该程序提示用户输入一个城市名称，查找对应城市的时区信息，根据当前时间（由 CMOS 提供）计算并显示城市的本地时间。如果输入的城市未找到，则输出默认消息 "I DO NOT KNOW :("。

典型结果：
输入：BEIJING
输出：UMT+8 BEIJING, CHINA 13:45

## 2023-3编程计算题

请编写程序段，实现运算（A*B+2024）/C+D*E，其中A、B、C、D、E均为有符号数字型变量名。程序必须考虑运算导致的字长改变（余数不计），并请说明你的最终运算结果字长。

```asm
datarea segment
        a       dw 506
        b       dw 4
        cc      dw 2          ;在真实的汇编语言编程中，c是一个关键字，会报错。但是考试还得怎么写
        d       dw 3
        e       dw 4
        ;这里的实例答案应该是07f4h
datarea ends
prognam segment
main proc far
                assume cs:prognam,ds:datarea
        start:  
                push   ds
                sub    ax,ax
                push   ax
                mov    ax,datarea
                mov    ds,ax
            
        ;(A*B+2024)/C+D*E
        ;考试从这儿开始写
                mov    ax,a
                mov    bx,b
                imul   bx                           ;(dx:ax)=ax*bx=a*b
                add    ax,2024                      ;(dx:ax)=a*b+2024
                adc    dx,0
                mov    bx,cc
                idiv   bx                           ;(dx:ax)/bx=ax...dx
                mov    bx,ax
                mov    ax,d
                mov    cx,e
                imul   cx                           ;(dx:ax)=ax*cx=d*e
                add    ax,bx
                adc    dx,0
        ;结果存在(dx:ax)里
        ;考试从这儿结束
                ret
main endp
prognam ends
end start
```

## 2023-4编程循环题

请编写完整程序实现新同学插入原班级名单并显示的功能。设班级名单为N个单元的数组，每个单元有10个字节。其中第一个字节存放着学号，其余9个字节存放学生英文姓名。假定起始时名单中已有n个同学，学号已按照姓名字母为序升序排列，现再从键盘接收一个姓名的输入，并插入已有名单。

```asm
datarea segment
    arr     db 1,'daniel   '
            db 2,'joana    '
            db 3,'misaka   '
            db 4,'xxw      '
            db 5,'zeyuwang '
            db 10 dup(?)
    n       db 5
    buf     db 9,?,9 dup(' ')
datarea ends
prognam segment
main proc far
            assume cs:prognam,ds:datarea,es:datarea
    start:  
            push   ds
            sub    ax,ax
            push   ax
            mov    ax,datarea
            mov    ds,ax
            mov    es,ax

    ;输入新的姓名
            lea    dx,buf
            mov    ah,0ah
            int    21h
            call   crlf

            mov    bx,1
            sub    dx,dx
    search: 
    ;比较
    ; push   dx
    ; add    dl,30h
    ; mov    ah,02h
    ; int    21h
    ; pop    dx
            lea    di,buf[2]
            lea    si,arr[bx]
            mov    cl,buf[1]
            cld
            repe   cmpsb
            jge    find
            inc    dl
            add    bx,10
            cmp    dl,n
            jge    find
            jmp    search
            
    ;找到了,插入排序。dh放当前索引，bx放实际偏移地址
    find:   
            mov    al,n
            mov    dh,10
            mul    dh                                  ;ax=10*n
            mov    bx,ax
            mov    dh,n
    ;后边数都往后挪，腾出一个空位，把输入的信息插入
    sort:   
            cmp    dh,dl
            jle    insert
            push   dx
            lea    si,arr[bx-10]
            lea    di,arr[bx]
            mov    cl,10
            cld
            rep    movsb
            inc    arr[bx]
            pop    dx
            sub    bx,10
            dec    dh
            jmp    sort
    insert: 
    ;用空格先填充
            lea    di, arr[bx+1]
            mov    al, ' '
            mov    cx, 9
            cld
            rep    stosb
    ;填入新的索引
            mov    arr[bx],dh
            inc    arr[bx]
    ;将名字插入
            lea    si,buf[2]
            lea    di,arr[bx+1]
            mov    cl,buf[1]
            cld
            rep    movsb
            inc    n                                   ;总数加1
            call   output
            ret
main endp
output proc
            sub    bx,bx
            sub    cl,cl
    o1:     
            mov    si,1
            mov    dl,arr[bx]                          ;懒了，按一位数算
            add    dl,30h
            mov    ah,2
            int    21h
            mov    dl,' '
            mov    ah,2
            int    21h
    o2:     
            mov    dl,arr[bx+si]
            mov    ah,2
            int    21h
            inc    si
            cmp    si,10
            jl     o2
            call   crlf
            inc    cl
            add    bx,10
            cmp    cl,n
            jl     o1
            ret
output endp
crlf proc
            push   dx
            mov    dl,0dh
            mov    ah,02h
            int    21h
            mov    dl,0ah
            mov    ah,02h
            int    21h
            pop    dx
            ret
crlf endp
prognam ends
end start
```

## 2023-5编程中断题

请完整程序采用接管1CH中断的方法实现在一小时倒计时的功能。程序开始时从59分59秒开始倒计时，每秒刷新一次时间。当计时回到00:00时重新从59:59开始倒计时。

```asm
datarea segment
    min     db 59
    sec     db 59
    count   db 18
datarea ends
prognam segment
main proc far
              assume cs:prognam,ds:datarea,es:datarea
    start:    
              push   ds
              sub    ax,ax
              push   ax
              mov    ax,datarea
              mov    ds,ax
              mov    es,ax
    ;取中断向量
              mov    al,1ch
              mov    ah,35h
              int    21h
              push   es
              push   bx
    ;设置中断向量
              push   ds
              mov    ax,seg countdown
              mov    ds,ax
              mov    dx,offset countdown
              mov    al,1ch
              mov    ah,25h
              int    21h
              pop    ds
    ;打开定时器
              in     al,21h
              and    al,0feh                             ;11111110b
              out    21h,al
              sti
    ;循环20000*30000次，因为次数太多一个寄存器装不下
              mov    di,20000
    delay:    
              mov    si,30000
    delay1:   
              dec    si
              jnz    delay1
              dec    di
              jnz    delay
    ;恢复中断向量
              pop    dx
              pop    ds
              mov    al,1ch
              mov    ah,25h
              int    21h
              ret
main endp
countdown proc
              push   ds
              push   ax
              push   cx
              push   dx

              mov    ax,datarea
              mov    ds,ax
              sti

              dec    count
              jnz    exit
              mov    count,18
              call   output
              cmp    sec,0
              jne    sdec
              mov    sec,60
              cmp    min,0
              jne    mdec
              mov    min,60
    mdec:     dec    min
    sdec:     dec    sec

    exit:     
              pop    dx
              pop    cx
              pop    ax
              pop    ds
              iret
countdown endp
output proc
              mov    al,min
              call   putnum
              mov    dl,':'
              call   putchar
              mov    al,sec
              call   putnum
              mov    dl,0dh
              call   putchar
              ret
output endp
putnum proc
              cbw
              mov    bl,10
              div    bl
              push   ax
              mov    dl,al
              add    dl,'0'
              call   putchar
              pop    ax
              mov    dl,ah
              add    dl,'0'
              call   putchar
              ret
putnum endp
putchar proc
              mov    ah,2
              int    21h
              ret
putchar endp
prognam ends
end start
```

dty:
```

data segment
    count dw 1
    hour dw 59d
    minute dw 59d
data ends
code segment
main proc far
assume cs:code,ds:data,es:data
start:
    push ds
    sub ax,ax
    push ax
    mov ax,data
    mov ds,ax
    mov es,ax
    mov al,1ch
    mov ah,35h
    int 21h
    push es
    push bx
    push ds

    mov dx,offset cal
    mov ax,seg cal
    mov ds,ax
    mov al,1ch
    mov ah,25h
    int 21h
    pop ds

    sti

    mov di,20000
dec1:
    mov si,30000
dec2:
    dec si
    jnz dec2
    dec di
    jnz dec1

    pop dx
    pop ds
    mov al,1ch
    mov ah,25h
    int 21h
    ret

main endp
cal proc near
    push dx
    push bx
    push cx
    push ax

    dec count
    jnz exit

    sti

    ; mov ah,02h
    ; mov bh,00h
    ; mov dh,00h
    ; mov dl,00h
    ; int 10h

    mov bx,hour
    call display
    mov dl,':'
    mov ah,02h
    int 21h
    mov bx,minute
    call display
    mov bx,minute
    cmp bx,0
    jz jiewei
    dec minute
    jmp exit2
jiewei:
    mov bx,hour
    cmp bx,0
    jz newbegin
    dec hour
    mov bx,59d
    mov minute,bx
    jmp exit2
newbegin:
    mov bx,59d
    mov hour,bx
    mov minute,bx  

exit2:
    mov count,18d
exit:
    cli
    pop ax
    pop cx
    pop bx
    pop dx
    iret
cal endp
display proc near
    mov cx,10d
    call dec_div
    mov cx,1d
    call dec_div
    ret
display endp
dec_div proc near
    mov ax,bx
    mov dx,0
    div cx
    mov bx,dx
    mov dl,al
    mov ah,02h
    add dl,30h
    int 21h
    ret
dec_div endp
code ends
end start
```

wn
```asm
dseg	segment
	count	dw	1
	hour	dw	59
	min		dw	60
dseg	ends
cseg	segment
	assume	cs:cseg,ds:dseg,es:dseg
main	proc	far
start:
	push	ds
	sub		ax,ax
	push	ax

	mov		ax,dseg
	mov		ds,ax
	mov		es,ax
begin:
	mov		al,1ch
	mov		ah,35h
	int		21h
	push	es
	push	bx

	push	ds
	mov		ax,seg	ring
	mov		ds,ax
	mov		dx,offset	ring
	mov		al,1ch
	mov		ah,25h
	int		21h
	pop		ds

	in		al,21h
	and		al,11111110b
	out		21h,al
	sti

	mov		si,3000h
loop1:
	mov		di,3000h
loop2:
	dec		di
	jnz		loop2
	dec		si
	jnz		loop1

	pop		dx
	pop		ds
	mov		al,1ch
	mov		ah,25h
	int		21h

	ret
main	endp
ring	proc	near
	push	ds
	mov		ax,dseg
	mov		ds,ax

	dec		count
	jnz		exit
	dec		min
	cmp		min,0
	jge		print
	mov		ax,59
	mov		min,ax
	dec		hour
	cmp		hour,0
	jge		print
	mov		ax,59
	mov		min,ax
	mov		hour,ax
print:
	mov		bx,hour
	mov		cx,10
	call	disp
	mov		cx,1
	call	disp

	mov		dl,':'
	mov		ah,02h
	int		21h

	mov		bx,min
	mov		cx,10
	call	disp
	mov		cx,1
	call	disp

	mov		dl,10
	mov		ah,02h
	int		21h

	mov		dl,13
	mov		ah,02h
	int		21h

	mov		ax,18
	mov		count,ax
exit:
	cli
	pop		ds
	iret
ring	endp
disp	proc	near
	mov		ax,bx
	mov		dx,0
	idiv	cx
	mov		bx,dx
	mov		dl,al
	add		dl,30h
	mov		ah,02h
	int		21h
	ret
disp	endp
cseg	ends
	end		start
```
## 2023附录

附录1：DOS系统功能调用（INT 21H）

| AH  | 功能             | 调用参数                                       | 返回参数                  |
| --- | ---------------- | ---------------------------------------------- | ------------------------- |
| 01  | 键盘输入并回显   |                                                | AL=输入的字符             |
| 02  | 显示输出         | DL=输出字符                                    |                           |
| 09  | 显示字符串       | DS：DX=串地址，串以'$'结束                     |                           |
| 0A  | 键盘输入到缓冲区 | DS：DX=缓冲区首址<br>(DS：DX)=缓冲区最大字符数 | (DS：DX)=实际输入的字符数 |
| 25  | 设置中断向量     | DS：DX=中断向量<br>AL=中断类型号               |                           |
| 35  | 取中断向量       | AL=中断类型号                                  | ES：BX=中断向量           |

1CH中断每秒钟约产生18次

附录2：CMOS RAM 中的时间信息

| 单元 | 存放内容 |
| ---- | -------- |
| 0    | 秒       |
| 2    | 分       |
| 4    | 时       |
| 7    | 日       |
| 8    | 月       |
| 9    | 年       |

这些数据以BCD码的方式存放。

从CMOS RAM 中读取信息的方式是：

```
OUT 70H, XX ; XX 为要访问的单元地址
IN AL, 71H   ; 从单元处读取数据
```
