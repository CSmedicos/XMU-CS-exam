# 2011汇编

[toc]

```asm
code segment
此处省略前面的初始化
mov ax,b
imul c
mov cx,ax
mov bx,dx
mov ax,a
cwd
add cx,ax
adc bx,dx
mov ax,120
cwd
sub ax,cx
sbb dx,bx
idiv d
mov E,ax
mov E+2,dx
code ends
```

## 1、读程序题

<details>
<summary>题目代码</summary>

```asm
data segment
    string1 db 'Please input 3 numbers!',13,10,'$'
    string2 db "The max of the first 2 numbers is:$"
    string3 db 'The max of the first 3 numbers is:$'
    num1    dw ?
    num2    dw ?
    num3    dw ?
data ends

code segment
main proc far
MAX MACRO K,A,B,C
               LOCAL  NEXT,OUT
               MOV      BX,A
               IF        K-2
               CMP      C,BX
               JLE      NEXT
               MOV      BX,C
               ENDIF
        NEXT: 
               CMP      B,BX
               JLE      OUT
               MOV      BX,B
        OUT:   
ENDM
          assume cs:code,ds:data,es:data
    start:
          push   ds
          sub    ax,ax
          push   ax
          mov    ax,data
          mov    ds,ax
          mov    es,ax
          lea    dx,string1
          mov    ah,09h
          int    21h
          mov    cx,3
          lea    si,num1
    input:
          call   decibin    ;☆
          mov    [si],bx
          add    si,2
          call   crlf
          loop   input
          MAX    2,num1,num2 ;①
          lea    dx,string2
          mov    ah,09h
          int    21h
          call   binihex
          call   crlf
          MAX    3,num1,num2,num3 ;②
          lea    dx,string3
          mov    ah,09h
          int    21h
          call   binihex
          ret
main endp
decibin proc near
        push cx
        mov bx,0
    newchar:
        mov ah,1
        int 21h
        sub al,30h
        jl exit
        cmp al,9d
        jg exit
        cbw
        xchg ax,bx
        mov cx,10d
        mul cx
        xchg ax,bx
        add bx,ax
        jmp newchar
    exit:
        pop cx
        ret
decibin endp
crlf proc near
        mov dl,0dh
        mov ah,2
        int 21h
        mov dl,0ah
        mov ah,2
        int 21h
        ret
crlf endp
binihex proc near
        mov ch,4
    rotate:
        mov cl,4
        rol bx,cl
        mov al,bl
        and al,0fh
        add al,30h
        cmp al,3ah
        jl printit
        add al,7h
    printit:
        mov dl,al
        mov ah,2
        int 21h
        dec ch
        jnz rotate
        mov dl,48H
        mov ah,2
        int 21h
        ret
binihex endp
code ends
    end start
```

</details>

(1)请给出程序运行的可能结果,并加以说明。(9分)

(2)请给出指令①、②展开后的结果(5分)
不考宏，略
(3)请给出指令☆执行前后的堆栈段使用情况(6分)

|☆执行前|
|---|
||
||
|0|
|(ds)|

|☆执行后|
|---|
||
||
|0|
|(ds)|

## 2、填空题

1、无答案版

仓库管理中，存有有关库存品的编号、名称情况的表格，根据用户提供的编号可以找到有关材料名。假设表格中共有六种库存品，以下程序可根据用户提供的两位编号在终端上显示其名称。

```asm
datasg segment para 'data'
    mess1   db      'stock number?', 13, 10, '$'    ;
            stoknin label byte
1)
2)
3)
    ;
    stoktab db      '05', 'Excavtors '
            db      '08', 'Lifters '
            db      '09', 'Presses '
            db      '12', 'Vavles '
            db      '23', 'Processors '
            db      '27', 'Pumps '
    ;
    descrn  db      14 dup(20h), 13, 10, '$'
    mess    db      'Not in table!', '$'
datasg ends
;***********************************************
codesg segment para 'code'
           assume cs: codesg, ds: datasg, es: datasg
    ;-----------------------------------------------
main proc far
           push   ds
           sub    ax, ax
           push   ax
           mov    ax, datasg
           mov    ds, ax
4)
    start: 
           lea    dx, mess1
           mov    ah, 09
           int    21h
           lea    dx, stoknin
           mov    ah, 0ah
           int    21h
           cmp    act, 0
5)
           mov    al, stokn
           mov    ah, stokn+1
           mov    cx, 06
           lea    si, stoktab
    a20:   
           cmp    ax, word ptr [si]
6)
           add    si, 14
7)
           lea    dx, mess
           mov    ah, 09
           int    21h
           jmp    exit
    a30:   
8)
9)
10)
    ;
           lea    dx, descrn
           mov    ah, 09
           int    21h
           jmp    start
    exit:  
           ret
main endp
    ;----------------------------------------------
codesg ends
;**********************************************
end main
```

2、答案版

```asm
datasg segment para 'data'
mess1 db 'stock number?', 13, 10, '$';
;
stoknin label byte
 1)max db 3
 2)act db ?
 3)stokn db 3 dup(?);这里标准答案是5 dup(?)，我不理解
;
stoktab db '05', 'Excavtors '
db '08', 'Lifters '
db '09', 'Presses '
db '12', 'Vavles '
db '23', 'Processors '
db '27', 'Pumps '
;
descrn db 14 dup(20h), 13, 10, '$'
mess db 'Not in table!', '$'
datasg ends
;***********************************************
codesg segment para 'code'
assume cs: codesg, ds: datasg, es: datasg
;-----------------------------------------------
main proc far
push ds
sub ax, ax
push ax
mov ax, datasg
mov ds, ax
4)mov es,ax
start:
lea dx, mess1
mov ah, 09
int 21h
lea dx, stoknin
mov ah, 0ah
int 21h
cmp act, 0
5)jle exit
mov al, stokn
mov ah, stokn+1
mov cx, 06
lea si, stoktab
a20:
cmp ax, word ptr [si]
6)jz a30
add si, 14
7)loop a20
lea dx, mess
mov ah, 09
int 21h
jmp exit
a30:
 8)lea di,descrn
 9)mov cx,14
 10)rep movsb
;
lea dx, descrn
mov ah, 09
int 21h
jmp start
exit:
ret
main endp
;----------------------------------------------
codesg ends
;**********************************************
end main
```

<details>
<summary>一样的答案</summary>

```asm
datasg segment para 'data'
    mess1   db      'stock number?', 13, 10, '$'    ;
    ;
            stoknin label byte
    max     db      2                               ;1)
    act     db      ?                               ;2)
    stokn   db      2 dup(?)                        ;3)
    ;
    stoktab db      '05', 'Excavtors   '
            db      '08', 'Lifters     '
            db      '09', 'Presses     '
            db      '12', 'Vavles      '
            db      '23', 'Processors  '
            db      '27', 'Pumps       '
    ;
    descrn  db      14 dup(20h), 13, 10, '$'
    mess    db      'Not in table!', '$'
datasg ends
;***********************************************
codesg segment para 'code'
           assume cs: codesg, ds: datasg, es: datasg
    ;-----------------------------------------------
main proc far
           push   ds
           sub    ax, ax
           push   ax
           mov    ax, datasg
           mov    ds, ax
           mov    es,ax                                 ;4)
    start: 
    ;输出'stock number?'
           lea    dx, mess1
           mov    ah, 09
           int    21h
    ;输入stoknin
           lea    dx, stoknin
           mov    ah, 0ah
           int    21h
    ;没输入
           cmp    act, 0
           jz     exit                                  ;5)
           mov    al, stokn                             ;十位
           mov    ah, stokn+1                           ;个位
           mov    cx, 06
           lea    si, stoktab                           ;表头
    a20:   
           cmp    ax, word ptr [si]                     ;比较
           jz     a30                                   ;6)
           add    si, 14
           loop   a20                                   ;7)
           lea    dx, mess
           mov    ah, 09
           int    21h
           jmp    exit
    a30:   
           lea    di,descrn                             ;8)
           mov    cx,14                                 ;9)
           rep    movsb                                 ;10)
    ;输出答案
           lea    dx, descrn
           mov    ah, 09
           int    21h
           jmp    start
    exit:  
           ret
main endp
    ;----------------------------------------------
codesg ends
;**********************************************
end main
```

</details>

## 3、

已知 A, B, C, D 为 16 位带符号数，请编写程序段计算 [120 - (A + B * C)] / D，并将商和余数依次保存到以 E 开头的连续两个字空间中。（20分）

```
data segment
E dw 2 dup(?)
data ends
code segment
此处省略前面的初始化
mov ax,b
imul c
mov cx,ax
mov bx,dx
mov ax,a
cwd
add cx,ax
adc bx,dx
mov ax,120
cwd
sub ax,cx
sbb dx,bx
idiv d
mov E,ax
mov E+2,dx
code ends
```

## 4、循环分支题

```asm
datarea segment
        names   db    10 dup(20 dup(' '))
                bufin label byte
        max     db    20
        act     db    ?
        buf     db    20 dup(?)
        count   db    0
        msg     db    'Please input the name:','$'
datarea ends
stack segment
stack ends
prognam segment
main proc far
                assume cs:prognam,ds:datarea,es:datarea
        start:  
                push   ds
                sub    ax,ax
                push   ax
                mov    ax,datarea
                mov    ds,ax
                mov    es,ax

                mov    bx,0
        input:  
                lea    dx,msg
                mov    ah,9
                int    21h
                lea    dx,bufin
                mov    ah,0ah
                int    21h
                call   crlf

                cmp    act,0
                jz     sort
                lea    si,buf
                lea    di,names[bx]
                xor    ch,ch
                mov    cl,act
                cld
                rep    movsb

                inc    count
                add    bx,20
                cmp    count,10
                jge    sort
                jmp    input
        sort:   
                cmp    count,0
                jz     exit
                cmp    count,1
                jz     output
                xor    ch,ch
                mov    cl,count
                dec    cx
                lea    si,names
        sort1:  
                push   cx
                mov    di,si
        sort2:  
                add    di,20
                push   cx
                mov    cx,20
        ;注意repe会改变si和di的值，所以要push和pop si和di
                push   si
                push   di
                cld
                repe   cmpsb
                pop    di
                pop    si
                jle    no_swap
                mov    bx,0
        swap:   
                mov    dh,[bx+si]
                mov    dl,[bx+di]
                mov    [bx+si],dl
                mov    [bx+di],dh
                inc    bx
                cmp    bx,20
                jl     swap
        no_swap:
                pop    cx
                loop   sort2
                add    si,20
                pop    cx
                loop   sort1
        output: 
                lea    si,names
                mov    cl,count
        puts:   
                push   cx
                mov    cx,20
        putchar:
                mov    dl,[si]
                mov    ah,2
                int    21h
                inc    si
                loop   putchar
                call   crlf
                pop    cx
                loop   puts
        exit:   
                ret
main endp
crlf proc
                mov    dl,0dh
                mov    ah,2
                int    21h
                mov    dl,0ah
                mov    ah,2
                int    21h
                ret
crlf endp
prognam ends
end start
```

## 5、中断

```asm
datarea segment
    count db 1
    n db 10
    char db '1'
datarea ends
prognam segment
main proc far
    assume cs:prognam,ds:datarea,es:datarea
start:
    push ds
    sub ax,ax
    push ax
    mov ax,datarea
    mov ds,ax
    mov es,ax
;取中断向量
    mov al,1ch
    mov ah,35h
    int 21h
    push es
    push bx
;设置新中断向量
    push ds
    mov ax,seg check
    mov ds,ax
    mov dx,offset check
    mov al,1ch
    mov ah,25h
    int 21h
    pop ds
;打开计时器
    in al,21h
    and al,11111110b
    out 21h,al
    sti
;循环
    mov si,20000
delay:mov di,30000
delay1:dec di
    jnz delay1
    dec si
    jnz delay
;恢复原中断向量
    pop dx
    pop ds
    mov al,1ch
    mov ah,25h
    int 21h
    ret
main endp
check proc
    push ds
    push ax
    push cx
    push dx

    mov ax,datarea
    mov ds,ax
    sti

    dec count
    jnz exit
    mov count,18
    
    mov dl,char
    mov ah,2
    int 21h
    mov dl,0dh
    mov ah,2
    int 21h
    mov dl,0ah
    mov ah,2
    int 21h

    dec n
    jnz exit
    mov n,10
    cmp char,'1'
    je one
    mov char,'1'
    jmp exit
one:mov char,'0'
exit:
    pop dx
    pop cx
    pop ax
    pop ds
    iret
check endp
prognam ends
end start
```
